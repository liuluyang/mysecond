OpenStack有一组样式准则为了清楚。 OpenStack是一个非常大的代码库（超过100万行的python），跨越几十个git树，超过一千开发人员每12个月贡献一次。因为这样的通用风格帮助开发人员理解评论中的代码，顺利地在项目之间移动，并且使代码更易于维护。

评论

不要影响内置或保留字。阴影内置或保留字使代码更难理解。例：

阴影
处理

本文档给出了Python代码的编码约定，包括主Python分发中的标准库。请参阅在Python的C实现[1]中描述C代码的样式指南的伴随信息PEP。

本文档和PEP 257（Docstring约定）改编自Guido的原始Python风格指南文章，以及Barry的风格指南[2]的一些补充。

这种风格指南随着时间的推移而发展，因为额外的约定被识别，并且过去的约定由于语言本身的变化而过时。

许多项目都有自己的编码风格指南。如果发生任何冲突，此项目的具体指南优先。

愚蠢的一致性是小心灵的大地精
一致性

Guido的主要见解之一是，代码的阅读频率要高于编写的代码。这里提供的指南旨在提高代码的可读性，并使其在广泛的Python代码中保持一致。正如PEP20所说，“可读性计数”。

样式指南是关于一致性。与此风格指南的一致性很重要。项目内的一致性更重要。一个模块或功能内的一致性是最重要的。

但是，知道什么时候不一致 - 有时风格指南建议只是不适用。当有疑问时，使用你最好的判断。看看其他例子，并决定什么是最好的。和不要犹豫问！

特别是：不要破坏向后兼容性只是为了遵守这个PEP！

忽略某个特定指南的其他一些好的理由：

当应用指南将使代码更不可读，即使对于习惯于阅读遵循此PEP的代码的人。

为了与周围的代码一致，也打破了它（可能是历史原因） - 虽然这也是一个机会，清理别人的混乱（在真正的XP风格）。

因为有问题的代码先于指南的引入，没有其他理由来修改该代码。

当代码需要保持与旧版本的Python不兼容，不支持的风格指南推荐的功能

每个缩进级别使用4个空格。

连续行应该使用Python的隐式线连接圆括号，括号和大括号，或使用悬置缩进[7]垂直使用封装元素。使用悬挂缩进时应考虑以下因素：第一行应该没有参数，应该使用进一步的缩进来清楚地将它自己区分为连续行。
对齐开放分隔符。
包括更多的缩进，以区别于其余。

悬挂缩进应添加级别。

第一行上的参数在不使用垂直对齐时被禁止。

作为缩进所需的进一步缩进是不可区分的。

对于连续行，4空间规则是可选的。

悬挂缩进*可以缩进到4个空格以外的缩进。

当if语句的条件部分足够长，需要跨越多行写入时，值得注意的是，两个字符关键字（即if），加上单个空格，加上开始括号的组合创建了一个自然用于多行条件的后续行的4空间缩进。这可能与嵌套在if-state中的缩进代码套件产生视觉冲突，这也将自然缩进到4个空格。此PEP在如何（或是否）进一步可视地区分这些条件行与if语句中的嵌套套件没有明确的位置。在这种情况下可接受的选项包括但不限于：

没有额外的缩进。

＃添加注释，这将在编辑器中提供一些区别
＃支持语法高亮。

＃在条件连续行上添加一些额外的缩进。

另请参见下面讨论是否在二进制运算符之前或之后中断

多行结构上的结束括号/括号/括号可以排列在列表最后一行的第一个非空格字符下，如：

空格是首选缩进方法。


有关多行if语句的进一步想法，请参阅前面的讨论



空格是首选缩进方法。

标签应仅用于与已缩进标签的代码保持一致。

Python 3禁止混合使用制表符和空格来缩进。

带有选项卡和空格混合的Python 2代码应该转换为仅使用空格。

当使用-t选项调用Python 2命令行解释器时，它会发出关于非法混合制表符和空格的代码的警告。使用-tt时，这些警告将成为错误。强烈推荐这些选项！

将所有行限制为最多79个字符。

对于具有较少结构限制（文档字符串或注释）的长文本块，行长度应限制为72个字符。

限制所需的编辑器窗口宽度可以使多个文件并行打开，并且在使用在相邻列中呈现两个版本的代码复查工具时效果很好。

大多数工具中的默认包装破坏了代码的可视化结构，使其更难理解。选择限制以避免在窗口宽度设置为80时在编辑器中进行换行，即使工具在换行时在最后一列中放置一个标记字形。一些基于网络的工具可能不提供动态线包装。

一些团队强烈喜欢较长的线路长度。对于专门或主要由能够就此问题达成一致的团队维护的代码，可以将标称行长度从80增加到100个字符（有效地将最大长度增加到99个字符），前提是仍然包含注释和docstrings为72个字符。

Python标准库是保守的，需要限制行为79个字符（和docstrings /注释72）。

包装长行的首选方法是使用括号，括号和大括号中的Python隐式行继续。通过在括号中包装表达式，可以在多行上打断长行。这些应该优先使用反斜杠为行连续。

反斜杠有时可能仍然适用。例如，long，with -statements不能使用隐式继续，因此反斜杠是可以接受的：

另一个这样的情况是使用断言语句。

确保适当缩进连续行。


应该在二元运算符之前还是之后换行？
几十年来，推荐的风格是打破二元运算符。但是这可以通过两种方式损害可读性：操作符倾向于分散在屏幕上的不同列上，并且每个操作符都被移动离开其操作数并且移动到前一行。在这里，眼睛必须做额外的工作，以告诉哪些项目被添加和减去：

操作符远离它们的操作数

为了解决这个可读性问题，数学家和他们的出版商遵循相反的约定。 Donald Knuth解释了他的计算机和排版系列中的传统规则：“虽然段落中的公式总是在二进制运算和关系之后断开，显示的公式总是在二进制运算之前断开”[3]。

遵循数学的传统通常产生更可读的代码：

容易匹配具有操作数的运算符

在Python代码中，允许在二进制运算符之前或之后中断，只要规则在本地是一致的。对于新代码，建议Knuth的样式。

用两个空行围绕顶层函数和类定义。

类中的方法定义由单个空白行包围。

可以使用（节省）额外的空白行来分隔相关功能组。在一束相关的一行（例如一组伪实现）之间可以省略空行。

在函数中使用空行，谨慎地指示逻辑节。

Python接受control-L（即^ L）形式的feed字符作为空格;许多工具将这些字符视为页面分隔符，因此您可以使用它们分隔文件的相关节的页面。注意，一些编辑器和基于Web的代码查看器可能不会将control-L识别为表单Feed，并会在其位置显示另一个字形。

核心Python分布中的代码应始终使用UTF-8（或Python 2中的ASCII）。

使用ASCII（在Python 2中）或UTF-8（在Python 3中）的文件不应具有编码声明。

在标准库中，非默认编码应仅用于测试目的，或者当注释或docstring需要提及包含非ASCII字符的作者名称时;否则，使用\ x，\ u，\ U或\ N转义是在字符串文字中包含非ASCII数据的首选方式。

对于Python 3.0及更高版本，标准库（见PEP 3131）规定了以下策略：Python标准库中的所有标识符必须使用ASCII唯一标识符，并且应尽可能使用英语单词（在许多情况下，缩写和技术使用不是英语的术语）。此外，字符串字面值和注释也必须为ASCII。唯一的例外是（a）测试非ASCII特征的测试用例，和（b）作者的名字。名称不是基于拉丁字母的作者必须提供他们名字的拉丁音译。

鼓励有全球观众的开源项目采用类似的政策

导入通常应在单独的行上

Yes: import os
     import sys

No:  import sys, os

这是可以说这虽然。

导入总是放在文件的顶部，只是在任何模块注释和docstrings之后，在模块全局变量和常量之前。

导入应按以下顺序分组：

标准库导入
相关第三方进口
本地应用程序/库特定导入
您应该在每组导入之间放置一个空行。

建议使用绝对导入，因为如果导入系统配置不正确（例如，当包中的目录在sys.path中结束时），它们通常更具可读性，并且更好地表现（或者至少提供更好的错误消息）：

import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example

然而，显式相对导入是绝对导入的可接受替代，特别是在处理复杂包布局时，使用绝对导入将不必要冗长：

标准库代码应避免复杂的包布局，并始终使用绝对导入。

不应该使用隐式相对导入，并且已在Python 3中删除。



当从包含类的模块导入类时，通常可以拼写：

如果此拼写导致本地名称冲突，则拼写他们
 

应该避免通配符导入（从<module> import *），因为它们使得不清楚名称空间中存在哪些名称，使读者和许多自动化工具混淆。对于通配符导入，有一个可辩护的用例，即将内部接口重新发布为公共API的一部分（例如，使用可选加速器模块的定义覆盖接口的纯Python实现，以及将哪些定义重写不是预先知道的）。

当以这种方式重新发布名称时，有关公共和内部接口的以下准则仍然适用。


模块级dunder名称
模块级别“dunders”（即具有两个前导和两个尾随下划线的名称），例如__all__，__author__，__version__等应放在模块docstring之后，但在任何import语句之前，除了__future__导入。 Python强制future-imports必须在除了docstrings之外的任何其他代码之前出现在模块中。

For example:

"""This is the example module.

This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'

import os
import sys



字符串报价
在Python中，单引号字符串和双引号字符串是相同的。本PEP不提出这一建议。选择一个规则并坚持下去。但是，当字符串包含单引号或双引号字符时，请使用另一个以避免字符串中的反斜杠。它提高了可读性。

对于三重引用的字符串，始终使用双引号字符与PEP 257中的docstring约定保持一致。

表达式和语句中的空格
在以下情况下避免无关的空格：

紧接在括号，括号或大括号中。

在尾随逗号和后面的括号之间。

紧接在逗号，分号或冒号之前：

然而，在切片中，冒号像二进制运算符，并且在任一侧应该具有相等的量（将其视为具有最低优先级的运算符）。在扩展切片中，两个冒号必须具有相同的间隔量。异常：省略slice参数时，将省略空格。

在开始括号之前，开始函数调用的参数列表：

紧接在开始编制索引或切片的开括号之前：

分配（或其他）运算符周围的多个空格将其与另一个对齐。

Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )

Yes: foo = (0,)
No:  bar = (0, )

Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x

Yes:

ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]
No:

ham[lower + offset:upper + offset]
ham[1: 9], ham[1 :9], ham[1:9 :3]
ham[lower : : upper]
ham[ : upper]

Yes: spam(1)
No:  spam (1)

Yes: dct['key'] = lst[index]
No:  dct ['key'] = lst [index]

Yes:

x = 1
y = 2
long_variable = 3
No:

x             = 1
y             = 2
long_variable = 3



其他建议
避免在任何地方使用尾随空格。因为它通常是看不见的，它可以是混乱：例如。后面跟着空格和换行符的反斜杠不计为行连续标记。一些编辑器不保留它，许多项目（如CPython本身）有预提交钩子拒绝它。

总是用任意一边的单个空格包围这些二进制运算符：赋值（=），增加赋值（+ =， - =等），比较（==，<，>，！=，<>，<= ，in，not in，is，is not），布尔值（和，或，不）。

如果使用具有不同优先级的运算符，请考虑在具有最低优先级的运算符周围添加空格。使用自己的判断;但是，不要使用多个空格，并且在二进制运算符的两边始终具有相同数量的空格。

当用于表示关键字参数或默认参数值时，不要在=符号周围使用空格。

函数注释应该使用冒号的正常规则，并且在 - >箭头（如果存在）周围总是有空格。 （有关函数注释的更多信息，请参阅下面的函数注释。）

当将参数注释与默认值组合时，请在=符号周围使用空格（但仅适用于同时具有注释和默认值的参数）。

通常不鼓励复合语句（同一行上的多个语句）。

虽然有时可以在同一行上放置一个带有小体的if / for / while，但不要对multi-clause语句执行此操作。也避免折叠这么长的线！

而不是

当然不：


Yes:

i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
No:

i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)

Yes:

def complex(real, imag=0.0):
    return magic(r=real, i=imag)
No:

def complex(real, imag = 0.0):
    return magic(r = real, i = imag)


Yes:

def munge(input: AnyStr): ...
def munge() -> AnyStr: ...
No:

def munge(input:AnyStr): ...
def munge()->PosInt: ...



Yes:

def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
No:

def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...

Yes:

if foo == 'blah':
    do_blah_thing()
do_one()
do_two()
do_three()
Rather not:

if foo == 'blah': do_blah_thing()
do_one(); do_two(); do_three()


Rather not:

if foo == 'blah': do_blah_thing()
for x in lst: total += x
while t < 10: t = delay()
Definitely not:

if foo == 'blah': do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == 'blah': one(); two(); three()


何时使用结尾逗号
跟踪逗号通常是可选的，除非它们在构成一个元素的元组时是强制性的（在Python 2中，它们具有用于print语句的语义）。 
为了清楚起见，建议在（技术上冗余的）括号中包围后者。

Yes:

FILES = ('setup.cfg',)
OK, but confusing:

FILES = 'setup.cfg',

混乱

当尾逗点是多余的时，当使用版本控制系统时，值，参数或导入项目的列表预期随着时间的推移而延长时，它们通常是有帮助的。 模式是将每个值（等）自己放在一行上，总是添加一个尾随逗号，
并在下一行添加右括号/括号/括号。 但是，在结束定界符的同一行上使用结尾逗号没有意义（除了上面的单例元组的情况）。

FILES = [
    'setup.cfg',
    'tox.ini',
    ]
initialize(FILES,
           error=True,
           )
No:

FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)


注释
与代码相矛盾的评论比没有评论差。当代码更改时，始终优先保持注释的最新！

评论应该是完整的句子。如果注释是短语或句子，其第一个单词应该大写，除非它是以小写字母开头的标识符（从不改变标识符的情况！）。

如果注释较短，则可以省略结束处的期间。块注释通常包括由完整句子构成的一个或多个段落，并且每个句子应该在句点结束。

你应该在句子结束句之后使用两个空格。

当写英语时，请遵循Strunk和White。

来自非英语国家的Python代码：请用英语撰写您的意见，除非您有120％的人确信代码永远不会由不会说您的语言的人阅读。

块注释
块注释通常适用于它们后面的一些（或所有）代码，并缩进到与该代码相同的级别。块注释的每一行以＃和单个空格开始（除非它是注释中的缩进文本）。

块注释内的段落由包含单个＃的行分隔。

内联注释
谨慎使用内联注释。

内联注释是与语句在同一行上的注释。内联注释应至少与语句中的两个空格分隔。它们应该以＃和单个空格开始。

内联注释是不必要的，事实上分散注意力，如果他们说明显而易见。不要这样做：
x = x + 1                 # Increment x

x = x + 1                 # Compensate for border
补偿边框



文档字符串
编写好的文档字符串（a.k.a.“docstrings”）的约定在PEP 257中永久化。

写所有公共模块，函数，类和方法的docstrings。 Docstring对于非公共方法不是必需的，但是您应该有一个描述该方法的注释。此注释应显示在def行后面。

PEP 257描述了良好的docstring约定。请注意，最重要的是，结束多行文档字符串的“”“应该在一行上，例如：

对于一个线程docstrings，请保持关闭“”“在同一行。

命名约定
Python库的命名约定有点混乱，所以我们永远不会得到完全一致 - 然而，这里是目前推荐的命名标准。新模块和包（包括第三方框架）应写入这些标准，但是如果现有库具有不同的样式，则优选内部一致性。

压倒原则
作为API的公共部分对用户可见的名称应遵循反映用法而不是实现的约定。

描述：命名样式
有很多不同的命名风格。它有助于能够识别正在使用的命名风格，独立于它们的用途。

通常区分以下命名样式：

所以命名是因为它的字母颠簸的外观[4]）。这也有时被称为StudlyCaps。

单大写字母

注意：在CapWords中使用缩写时，大写缩写的所有字母。因此HTTPServerError比HttpServerError更好。

 （不同于大写字母的初始小写字符！）

还有使用短的唯一前缀来将相关名称分组在一起的风格。这在Python中不太用，但是为了完整性，它被提及。例如，os.stat（）函数返回一个元组，其项目传统上具有名称，如st_mode，st_size，st_mtime等。 （这是为了强调与POSIX系统调用结构的字段的对应，这有助于熟悉程序员）。

X11库使用前导X作为其所有公共函数。在Python中，这种风格通常被认为是不必要的，因为属性和方法名称以对象为前缀，函数名称以模块名称为前缀。

此外，将识别使用前导或尾随下划线的以下特殊形式（这些特殊形式通常可与任何案例公约结合使用）：

 弱“内部使用”指标。例如。从M import *不导入其名称以下划线开头的对象。
按惯例使用，以避免与Python关键字冲突。

 当命名类属性时，调用名称调整（在类FooBar中，__boo变为_FooBar__boo;见下文）。

“魔术”对象或属于用户控制的命名空间中的属性。例如。 __init__，__import__或__file__。从不发明这样的名字;只能使用它们作为文档。




规定：命名约定

要避免的名称
不要使用字符'l'（小写字母el），'O'（大写字母oh）或'I'（大写字母眼）作为单字符变量名。

在某些字体中，这些字符与数字1和零是无法区分的。当试图使用'l'时，使用'L'。

软件包和模块名称
模块应该具有短的，全小写的名称。如果提高可读性，可以在模块名称中使用下划线。 Python包也应该使用简短的全小写名称，尽管不鼓励使用下划线。

当用C或C ++编写的扩展模块具有提供更高级别（例如更多的面向对象）接口的伴随Python模块时，C / C ++模块具有前导下划线（例如_socket）。

类名
类名通常应该使用字典约定。



考虑到这一点，下面是Pythonic指南：

公共属性不应有前导下划线。

如果您的公共属性名称与保留的关键字相冲突，请在属性名称后面附加一个尾随下划线。这优于缩写或损坏的拼写。 （但是，尽管有这个规则，“cls”是已知为类的任何变量或参数的首选拼写，特别是类方法的第一个参数。）

注1：参见上面的类方法的参数名称推荐。

对于简单的公共数据属性，最好只暴露属性名称，没有复杂的访问器/ mutator方法。请记住，如果你发现一个简单的数据属性需要增长功能行为，Python提供了一个容易的未来增强的途径。在这种情况下，使用属性隐藏简单数据属性访问语法背后的功能实现。

注意1：属性只适用于新式类。

注2：尝试保持功能行为的副作用自由，虽然副作用，如缓存一般都很好。

注3：避免使用属性进行计算昂贵的操作;属性符号使得调用者相信访问是（相对）便宜的。

如果你的类打算被子类化，并且你有不想让子类使用的属性，请考虑使用双引号下划线和没有尾随下划线来命名它们。这会调用Python的名称管理算法，其中类的名称被转换为属性名称。这有助于避免属性名称冲突，子类不小心包含具有相同名称的属性。

注意1：注意，在标记名称中只使用简单的类名，因此如果子类选择相同的类名和属性名，您仍然可以获得名称冲突。

注意2：名称调整可以做某些用途，如调试和__getattr __（），不太方便。然而，名称管理算法有良好的文档和容易手动执行。

注3：不是每个人都喜欢名字纠结。尝试平衡避免意外名称冲突的需要与高级呼叫者的潜在使用。

公共和内部接口
任何向后兼容性保证仅适用于公共接口。因此，重要的是用户能够清楚地区分公共接口和内部接口。

文档化的接口被认为是公共的，除非文档明确声明它们是临时的或内部接口免于通常的向后兼容性保证。所有未记录的接口应假定为内部接口。

为了更好地支持内省，模块应该使用__all__属性在其公共API中显式声明名称。将__all__设置为空列表表示模块没有公共API。

即使适当地设置__all__，内部接口（包，模块，类，函数，属性或其他名称）仍应使用单个前导下划线作为前缀。

如果包含命名空间（包，模块或类）的任何内容被认为是内部的，则接口也被认为是内部的。

导入的名称应始终被视为实现细节。其他模块不能依赖于对这些导入的名称的间接访问，除非它们是包含模块的API的明确记录部分，
例如os.path或暴露子模块功能的包的__init__模块。

编程建议
代码应该以不会影响Python的其他实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。

例如，不要依赖于CPython对a + = b或a = a + b形式的语句的in-place字符串连接的高效实现。这种优化即使在CPython中也很脆弱（它只适用于某些类型），
并且在不使用引用计数的实现中根本不存在。在库的性能敏感部分，应该使用'.join（）形式。这将确保连接发生在跨各种实现的线性时间。

与单例类似的比较None应该总是使用is或者不是，永远不是相等运算符。

另外，要小心，如果x当你真的意味着如果x不是无 - 写。当测试是否将默认为None的变量或参数设置为某个其他值时。
另一个值可能有一个类型（如容器）在布尔上下文中可能为false。

使用不是运算符，而不是不是运算符。虽然两个表达式在功能上相同，但前者更可读和优选。

在接口被记录并且主要用作可调用的情况下，可以使用函数的命名约定。

请注意，内置名称有一个单独的约定：大多数内置名称是单个单词（或两个单词一起运行），CapWords约定仅用于异常名称和内置常量。

类型变量名称
在PEP 484中引入的类型变量的名称通常应该使用CapWords喜欢短名称：T，AnyStr，Num。建议将后缀_co或_contra添加到用于相应地声明协变或逆变行为的变量。例子：

从键入import TypeVar

异常名称
因为异常应该是类，所以类命名约定适用于此。但是，您应该对异常名称使用后缀“Error”（如果异常实际上是错误）。

全局变量名
（让我们希望这些变量只能在一个模块中使用。）约定与函数的约定大致相同。

被设计为通过M import *使用的模块应该使用__all__机制来防止导出全局变量，或者使用将这样的全局变量加上下划线的旧约定（
你可能想要这样做来表示这些全局变量是“模块非公开的“）。

函数名称
函数名称应为小写，必要时用下划线分隔词以提高可读性。

mixedCase只允许在已经是主流样式（例如threading.py）的上下文中，以保留向后兼容性。

函数和方法参数
始终对实例方法的第一个参数使用self。

总是使用cls作为类方法的第一个参数。

如果函数参数的名称与保留关键字冲突，通常最好附加一个尾随下划线，而不是使用缩写或拼写错误。因此class_比clss更好。 （
也许更好是通过使用同义词来避免这种冲突。）

方法名称和实例变量
使用函数命名规则：小写字母，用必要的下划线分隔词以提高可读性。

仅对非公共方法和实例变量使用一个前导下划线。

为了避免与子类发生名称冲突，使用两个前导下划线来调用Python的名称调整规则。

Python将这些名称改名为类名：如果Foo类有一个名为__a的属性，它不能被Foo .__ a访问。 （一个坚持的用户仍然可以通过调用Foo._Foo__a获得访问。）通常，
双引导下划线应该仅用于避免名称与设计为子类的类中的属性冲突。

注意：使用__names有一些争议（见下文）。

常量
常量通常在模块级上定义，并用所有大写字母表示，下划线分隔单词。示例包括MAX_OVERFLOW和TOTAL。


设计继承
总是决定类的方法和实例变量（统称为“属性”）应该是公共还是非公开。如有疑问，选择非公开;使公开的公开时间比公开的公开时间更容易。

公共属性是您期望类的不相关客户端使用的属性，您承诺避免向后不兼容的更改。非公共属性是不打算由第三方使用的属性;您不保证非公共属性不会更改或甚至删除。

我们在这里不使用术语“私有”，因为没有属性在Python中真的是私有的（没有一般不必要的工作量）。

另一类属性是属于“子类API”（在其他语言中通常称为“protected”）的一部分。一些类被设计为继承自，以扩展或修改类的行为的方面。当设计这样一个类时，
需要明确地决定哪些属性是公共的，哪些是子类API的一部分，哪些属性只能被你的基类使用。

考虑到这一点，下面是Pythonic指南：

公共属性不应有前导下划线。

如果您的公共属性名称与保留的关键字相冲突，请在属性名称后面附加一个尾随下划线。这优于缩写或损坏的拼写。 （但是，尽管有这个规则，“cls”是已知为类的任何变量或参数的首选拼写，特别是类方法的第一个参数。）

注1：参见上面的类方法的参数名称推荐。

对于简单的公共数据属性，最好只暴露属性名称，没有复杂的访问器/ mutator方法。请记住，如果你发现一个简单的数据属性需要增长功能行为，Python提供了一个容易的未来增强的途径。在这种情况下，使用属性隐藏简单数据属性访问语法背后的功能实现。

注意1：属性只适用于新式类。

注2：尝试保持功能行为的副作用自由，虽然副作用，如缓存一般都很好。

注3：避免使用属性进行计算昂贵的操作;属性符号使得调用者相信访问是（相对）便宜的。

如果你的类打算被子类化，并且你有不想让子类使用的属性，请考虑使用双引号下划线和没有尾随下划线来命名它们。这会调用Python的名称管理算法，其中类的名称被转换为属性名称。这有助于避免属性名称冲突，子类不小心包含具有相同名称的属性。

注意1：注意，在标记名称中只使用简单的类名，因此如果子类选择相同的类名和属性名，您仍然可以获得名称冲突。

注意2：名称调整可以做某些用途，如调试和__getattr __（），不太方便。然而，名称管理算法有良好的文档和容易手动执行。

注3：不是每个人都喜欢名字纠结。尝试平衡避免意外名称冲突的需要与高级呼叫者的潜在使用。

公共和内部接口
任何向后兼容性保证仅适用于公共接口。因此，重要的是用户能够清楚地区分公共接口和内部接口。

文档化的接口被认为是公共的，除非文档明确声明它们是临时的或内部接口免于通常的向后兼容性保证。所有未记录的接口应假定为内部接口。

为了更好地支持内省，模块应该使用__all__属性在其公共API中显式声明名称。将__all__设置为空列表表示模块没有公共API。

即使适当地设置__all__，内部接口（包，模块，类，函数，属性或其他名称）仍应使用单个前导下划线作为前缀。

如果包含命名空间（包，模块或类）的任何内容被认为是内部的，则接口也被认为是内部的。

导入的名称应始终被视为实现细节。其他模块不能依赖于对这些导入的名称的间接访问，除非它们是包含模块的API的明确记录部分，例如os.path或暴露子模块功能的包的__init__模块。

编程建议
代码应该以不会影响Python的其他实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写。

例如，不要依赖于CPython对a + = b或a = a + b形式的语句的in-place字符串连接的高效实现。这种优化即使在CPython中也很脆弱（它只适用于某些类型），并且在不使用引用计数的实现中根本不存在。在库的性能敏感部分，应该使用'.join（）形式。这将确保连接发生在跨各种实现的线性时间。

与单例类似的比较None应该总是使用is或者不是，永远不是相等运算符。

另外，要小心，如果x当你真的意味着如果x不是无 - 写。当测试是否将默认为None的变量或参数设置为某个其他值时。另一个值可能有一个类型（如容器）在布尔上下文中可能为false。

使用不是运算符，而不是不是运算符。虽然两个表达式在功能上相同，但前者更可读和优选。

Yes:

if foo is not None:
No:

if not foo is None:

当通过丰富的比较实现排序操作时，最好实现所有六个操作（__eq__，__ne__，__lt__，__le__，__gt__，__ge__），而不是依靠其他代码来执行特定的比较。

为了尽量减少工作量，functools.total_ordering（）装饰器提供了一个工具来生成缺少的比较方法。

PEP 207指示Python假定反射性规则。因此，解释器可以用x <y，y> = x交换y> x，其中x <= y，并且可以交换x == y和x！= y的自变量。 sort（）和min（）操作保证使用<operator，max（）函数使用> operator。但是，最好执行所有六个操作，以便在其他上下文中不会出现混淆。

始终使用def语句，而不是将lambda表达式直接绑定到标识符的赋值语句。

第一种形式意味着结果函数对象的名称具体为'f'而不是通用的'<lambda>'。这对于一般的跟踪和字符串表示更有用。使用赋值语句消除了lambda表达式可以提供超过显式def语句的唯一好处（即它可以嵌入在较大的表达式中）

从异常派生异常，而不是从BaseException。从BaseException的直接继承保留用于捕获它们的异常几乎总是错误的事情。

根据代码捕获异常的区别可能需要的设计异常层次结构，而不是引发异常的位置。目的是回答问题“出了什么问题？而不是仅仅说明“发生了一个问题”（参见PEP 3151，本例中学习了内置异常层次结构）

类命名约定适用于此处，但如果异常是错误，则应向后面的类添加后缀“Error”。用于非本地流控制或其他形式的信令的非错误例外不需要特殊的后缀。

适当地使用异常链接。在Python 3中，“从X提高X”应该用于指示显式替换，而不会丢失原始的追溯。

当故意替换一个内部异常（在Python 2中使用“raise X”或在Python 3.3+中“从X中引用X”）时，请确保将相关细节传递给新异常（例如，在将KeyError转换为AttributeError时保留属性名称，或者在新的异常消息中嵌入原始异常的文本）。

当在Python 2中引发异常时，使用raise ValueError（'message'），而不是较早的表单引发ValueError，'message'。

后者的形式不是合法的Python 3语法。

使用形式还意味着当异常参数为long或包含字符串格式时，由于包含括号，您不需要使用行连续字符。

当捕获异常时，尽可能提及特定的异常，而不是使用裸的except：子句。

例如，使用：

try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None


一个裸的except：子句将捕获SystemExit和KeyboardInterrupt异常，使得更难以使用Control-C中断程序，并且可以伪装其他问题。如果你想捕获所有表示程序错误的异常，使用except Exception：（除了相当于BaseException：）。

一个好的经验法则是将“except”子句的使用限制为两种情况：

如果异常处理程序将打印出来或记录traceback;至少用户将意识到已经发生错误。
如果代码需要做一些清理工作，但然后让异常向上传播与raise。 try ... finally可以是更好的办法来处理这种情况。

当绑定将异常捕获到名称时，更喜欢在Python 2.6中添加的显式名称绑定语法：

这是Python 3中唯一支持的语法，并避免与基于逗号的旧语法相关的歧义问题。
try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))


当捕获操作系统错误时，更喜欢在Python 3.3中引入的显式异常层次结构对errno值的内省。

此外，对于所有try / except子句，将try子句限制为必需的绝对最小代码量。 同样，这避免了掩蔽错误。

try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)
No:

try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)


当资源位于特定代码段的本地时，请使用with语句以确保在使用后能够及时可靠地清除该资源。 try / finally语句也是可以接受的。

只要上下文管理器执行除获取和释放资源之外的其他操作，就应该通过单独的函数或方法调用它们。例如：

Yes:

with conn.begin_transaction():
    do_stuff_in_transaction(conn)
No:

with conn:
    do_stuff_in_transaction(conn)

后一个示例不提供任何信息来指示__enter__和__exit__方法在事务后关闭连接之外的事情。在这种情况下，显式是重要的。

在返回语句中保持一致。函数中的所有return语句都应该返回一个表达式，或者它们都不应该返回。如果任何返回语句返回一个表达式，
任何没有返回任何值的返回语句都应该显式地声明为return None，并且在函数的结尾（如果可达的话）应该有一个显式返回语句。

Yes:

def foo(x):
    if x >= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x < 0:
        return None
    return math.sqrt(x)
No:

def foo(x):
    if x >= 0:
        return math.sqrt(x)

def bar(x):
    if x < 0:
        return
    return math.sqrt(x)

使用''.startswith（）和''.endswith（）而不是字符串切割来检查前缀或后缀。

startswith（）和endswith（）是更干净，更少的错误倾向。例如：

Yes: if foo.startswith('bar'):
No:  if foo[:3] == 'bar':

对象类型比较应该总是使用isinstance（），而不是直接比较类型。

Yes: if isinstance(obj, int):

No:  if type(obj) is type(1):


当检查对象是否是字符串时，请记住它可能是一个unicode字符串！在Python 2中，str和unicode有一个公共的基类，basestring，所以你可以做：
if isinstance(obj, basestring):
if isinstance(obj, basestring):

注意，在Python 3中，unicode和basestring不再存在（只有str），一个字节对象不再是一种字符串（它是一个整数序列）


对于序列（字符串，列表，元组），使用空序列为假的事实
Yes: if not seq:
     if seq:

No: if len(seq):
    if not len(seq):


不要写依赖于显着结尾空格的字符串文字。这样的尾部空格在视觉上难以区分，一些编辑器（或最近的reindent.py）将修剪它们。

不要使用==将布尔值与True或False进行比较。
Yes:   if greeting:
No:    if greeting == True:
Worse: if greeting is True:


函数注释
随着PEP 484的接受，功能注释的样式规则正在改变。

为了向前兼容，Python 3代码中的函数注释应该优选地使用PEP 484语法。 （上节中有一些注释的格式化建议。）

不再鼓励以前在本PEP中推荐的注释样式的实验。

然而，在stdlib之外，现在鼓励PEP 484规则中的实验。例如，使用PEP 484样式类型注释标记大型第三方库或应用程序，
查看添加这些注释的难易程度，并观察它们的存在是否提高代码可理解性。

Python标准库在采用这样的注释时应该保守，但是它们的使用允许用于新的代码和大的重构。

对于想要对函数注释进行不同使用的代码，建议使用以下形式的注释：

＃type：ignore
靠近文件的顶部;这告诉类型检查器忽略所有注释。 （在PEP 484中可以找到更多细粒度的禁止类型检查的投诉的方法。）

像linters，类型检查器是可选的，单独的工具。默认情况下，Python解释器不应该发出任何消息，由于类型检查，不应该改变他们的行为基于注释。

不想使用类型检查器的用户可以随意忽略它们。然而，期望第三方库包的用户可能想要在那些包上运行类型检查器。
为此，PEP 484建议使用存根文件：.pyi文件，由类型检查器读取，优先于相应的.py文件。存根文件可以通过类型库repo [5]与库一起发布，
也可以单独发布（通过库作者的许可）。

对于需要向后兼容的代码，可以以注释的形式添加类型注释。参见PEP 484 [6]的相关章节。

脚注

[7]悬置缩进是一种类型设置样式，其中段落中的所有行都缩进，除了第一行。在Python的上下文中，该术语用于描述一种样式，
其中括号语句的开始括号是该行的最后一个非空白字符，后续行将缩进，直到右括号。